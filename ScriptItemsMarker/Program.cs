
namespace ScriptItemsMarker;

#pragma warning disable CA1416

using System;
using Mutagen.Bethesda.WPF.Reflection.Attributes;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Skyrim;
using System.IO;
using System.Linq;
using Newtonsoft.Json;
using Noggog;
using static Mutagen.Bethesda.FormKeys.SkyrimSE.Skyrim.Keyword;
using System.Threading.Tasks;

public class Settings
{
  [SettingName("Mod name")]
  [Tooltip("Full name including extension")]
  public string ModName = "SomeEsp.esp";
  
  [SettingName("Keyword Form Id")]
  [Tooltip("Form Id of keyword in mod")]
  public uint FormId = 0x800;
}

public static class Program
{
  static Lazy<Settings> _settings = new();
  public static async Task<int> Main(string[] args)
  {
    return await SynthesisPipeline.Instance.AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
      .SetAutogeneratedSettings(nickname: "settings", path: "settings.json", out _settings)
      .SetTypicalOpen(GameRelease.SkyrimSE, new ModKey("ScriptItemsMarker.esp", ModType.Plugin))
      .Run(args);
  }

  private static void SynthesisLog(string message, bool special = false)
  {
    if (special)
    {
      Console.WriteLine();
      Console.Write(">>> ");
    }

    Console.WriteLine(message);
    if (special) Console.WriteLine();
  }

  private static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
  {
    var modName = _settings.Value.ModName;
    var formId = _settings.Value.FormId;
    
    SynthesisLog($"Script Items Marker Settings: {modName} {formId}", true);
    
    if (!state.LoadOrder.ContainsKey(modName))
      throw new Exception($"ERROR: {modName} not found in load order");

    var modKey = ModKey.FromNameAndExtension(modName);
    var formKey = new FormKey(modKey, formId);
    
    var exclusiveKeyword = state.LinkCache.Resolve<IKeywordGetter>(formKey);
    if (exclusiveKeyword == null)
      throw new Exception("ERROR: keyword not found in mod");
    
    foreach (var armor in state.LoadOrder.PriorityOrder.WinningOverrides<IArmorGetter>())
    {
      if (!(armor.VirtualMachineAdapter?.Scripts.Count > 0) || !armor.TemplateArmor.IsNull) continue;
      var modifiedArmor = state.PatchMod.Armors.GetOrAddAsOverride(armor);
      modifiedArmor.Keywords ??= new ExtendedList<IFormLinkGetter<IKeywordGetter>>();
      modifiedArmor.Keywords.Add(exclusiveKeyword);
      SynthesisLog($"Add keyword to armor: {modifiedArmor.EditorID}");
    }
    
    foreach (var weapon in state.LoadOrder.PriorityOrder.WinningOverrides<IWeaponGetter>())
    {
      if (!(weapon.VirtualMachineAdapter?.Scripts.Count > 0) || !weapon.Template.IsNull) continue;
      var modifiedWeapon = state.PatchMod.Weapons.GetOrAddAsOverride(weapon);
      modifiedWeapon.Keywords ??= new ExtendedList<IFormLinkGetter<IKeywordGetter>>();
      modifiedWeapon.Keywords.Add(exclusiveKeyword);
      SynthesisLog($"Add keyword to weapon: {modifiedWeapon.EditorID}");
    }
    
    foreach (var misc in state.LoadOrder.PriorityOrder.WinningOverrides<IMiscItemGetter>())
    {
      if (!(misc.VirtualMachineAdapter?.Scripts.Count > 0)) continue;
      var modifiedMisc = state.PatchMod.MiscItems.GetOrAddAsOverride(misc);
      modifiedMisc.Keywords ??= new ExtendedList<IFormLinkGetter<IKeywordGetter>>();
      modifiedMisc.Keywords.Add(exclusiveKeyword);
      SynthesisLog($"Add keyword to misc: {modifiedMisc.EditorID}");
    }
      
      

    SynthesisLog("Done patching script items marker!", true);
  }
}